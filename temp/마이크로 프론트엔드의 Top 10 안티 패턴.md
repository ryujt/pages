# 마이크로 프론트엔드의 Top 10 안티 패턴

## 숨겨진 모놀리스

마이크로 프론트엔드로 전환할 때 가장 주의해야 할 점 중 하나는 숨겨진 모놀리스를 만들지 않는 것입니다. 숨겨진 모놀리스란 마이크로 프론트엔드로 분리했지만, 실제로는 여전히 서로 강하게 결합되어 있어 독립적인 개발과 배포가 어려운 상태를 말합니다.

이런 상황은 보통 여러 마이크로 프론트엔드에 걸쳐 하나의 기능을 구현할 때 발생합니다. 기술적으로는 각 부분을 독립적으로 개발하고 배포할 수 있어야 하지만, 실제로는 그렇지 못한 경우가 많습니다. 이렇게 되면 모놀리식 아키텍처의 단점(예: 대규모 릴리즈에 많은 조율이 필요함)과 분산 시스템의 단점(예: 한 번에 모든 코드를 디버깅할 수 없음)을 모두 갖게 됩니다.

숨겨진 모놀리스의 주요 특징은 다음과 같습니다:

- 자율성 부족: 팀이 독자적으로 배포할 수 없고, 설사 배포한다 해도 추가적인 조율과 조정이 필요합니다.
- 복잡한 배포: 배포가 한 팀의 손에 달려 있지 않고, 조정이나 복잡한 CI/CD 설정이 필요합니다.
- 공유 상태: 모든 사람이 사용하지만 아무도 유지보수나 개발에 책임을 느끼지 않는 god object나 애플리케이션의 일부가 존재합니다.

이를 피하기 위해서는 도메인 주도 설계(DDD)를 적용하여 애플리케이션을 적절히 분할하고, 마이크로 프론트엔드 간의 느슨한 결합을 유지해야 합니다. 마이크로 프론트엔드 간의 의존성을 최소화하고, 각 팀이 자율적으로 개발과 배포를 할 수 있도록 해야 합니다. 이를 통해 진정한 의미의 마이크로 프론트엔드 아키텍처를 구현할 수 있습니다.

## 수다스러운 프론트엔드

마이크로 프론트엔드 간의 지나친 통신은 비효율적인 수다스러운 프론트엔드를 만들어낼 수 있습니다. 마이크로 프론트엔드는 분리된 특성상 서로 통신이 필요하지만, 모든 작업에 대해 이벤트를 발생시키는 것은 과도한 통신입니다. 

이런 과도한 통신은 UI 조각들 간의 효율성을 떨어뜨리고 개발을 어렵게 만듭니다. 이 안티 패턴의 주요 특징으로는 빈번한 이벤트 발생, 긴 호출 체인, 디버깅의 어려움 등이 있습니다.

따라서 정말 필요한 이벤트만 발생시키고, 관심 있는 마이크로 프론트엔드에만 이벤트를 도입하는 것이 좋습니다. 모든 작업에 이벤트를 남발하기보다는 꼭 필요한 통신만 하는 것이 마이크로 프론트엔드 간의 효율적인 협업을 가능하게 합니다.

## 프레임워크 광란

프레임워크 광란은 마이크로 프론트엔드를 도입하거나 옹호하는 가장 많이 사용되는 이유 중 하나입니다. 여러 프레임워크에서 컴포넌트를 렌더링할 수 있는 기능은 확실히 "멋진" 기능이지만, 이는 마이크로 프론트엔드에만 국한된 기능이 아니며 쉽게 남용해서는 안 되는 기능입니다.

서버에서 순수하게 렌더링되는 프레임워크를 사용하거나 Svelte와 같이 컴파일 시점에 사라지는 프레임워크를 사용한다면 비용이 거의 무시할 수 있을 정도로 적을 수 있습니다. 그럼에도 불구하고 불필요한 JavaScript가 전송될 때마다 성능이 저하됩니다.

여러 프레임워크를 도입하는 데 따른 성능 비용과는 별개로, 컴포넌트 간 통신에 어려움이 있을 것입니다. 또한 여러 영역의 애플리케이션을 이해하려고 할 때 인지적 부담이 증가할 것입니다. 단일 프레임워크에만 익숙한 사람들에게는 이해하기 어렵거나 불가능해질 수 있습니다.

이 안티패턴의 주요 특징은 다음과 같습니다:

- 나쁜 성능: 애플리케이션 로딩에 오랜 시간이 걸립니다. 대부분의 시간은 데이터를 로드하는 데 소요되는 것이 아니라 데이터를 로드하기 위한 코드를 로드하는 데 소요됩니다.
- 높은 복잡성: 단일 마이크로 프론트엔드를 넘어 코드를 이해하기 위해서는 여러 프레임워크와 그에 따른 특정 이슈와 철학에 대해 전문가가 되어야 합니다.
- XKCD 927: 기존 표준을 결합하기 위해 새로운 표준이 만들어졌습니다. 결국 목표로 했던 프레임워크 독립성을 달성했습니다. 그러나 이는 단순히 또 다른 프레임워크를 내부에서 호스팅하고 있다는 것을 의미합니다.

단일 기술로 정착하려고 노력하고, 정당한 경우에만 다른 프레임워크에 대한 지원을 도입하는 것이 좋습니다.

## 마이크로-모든 것

마이크로 프론트엔드로 전환할 때 가장 어려운 점 중 하나는 "올바른" 도메인 분해를 찾는 것입니다. 이상적인 도메인 분해를 찾는 것은 불가능할 수 있으므로 실용적인 것이 핵심입니다. 

기존의 하위 도메인에 쉽게 속하지 않는 기능을 만나면 새로운 하위 도메인에 새로운 마이크로 프론트엔드를 열고 싶을 수 있습니다. 이러한 접근 방식이 작동할 수는 있지만 매우 작은 마이크로 프론트엔드가 많이 생성되기 쉽습니다.

마이크로 프론트엔드가 너무 많으면 여러 가지 문제가 발생합니다. 유지 관리 및 일관성이 저하되고 인지 부하가 증가합니다.

전반적으로 더 나은 전략은 명확한 하위 도메인이 없는 마이크로 프론트엔드를 앱 쉘에 배치하는 것입니다(관련성이 더 기술적/도메인 특정적이지 않은 경우). 또는 "할당되지 않은" 모든 부분을 호스팅하는 특수 마이크로 프론트엔드에 배치하는 것입니다. 이렇게 하면 기능에 대한 명확한 지정이 설정되면 전용 마이크로 프론트엔드로의 전송이 더 의미가 있습니다.

이 안티 패턴의 주요 특성은 다음과 같습니다:

- 과도한 분열: 최종 사용자를 위한 단일 기능이 3개 이상의 마이크로 프론트엔드에 의해 제공됩니다.
- 참조 지옥: 분산된 부분이 너무 많아 본질적으로 모든 함수가 다른 원격 부분의 함수를 호출하게 됩니다.
- 낮은 응집력: 응집력은 모듈 내의 요소가 단일하고 잘 정의된 목적을 달성하기 위해 함께 작동하는 정도를 나타냅니다. 낮은 응집력에서는 요소가 느슨하게 관련되어 있고 여러 목적에 사용됩니다.

너무 일찍 분할하지 말고 가능한 한 가장 가까운 도메인/마이크로 프론트엔드에서 시작하고 명확한 하위 도메인이 나타난 후에만 추출하세요.

## 단일 책임 원칙 위반

여기서는 객체 지향 설계에서 모듈의 책임에 대한 근본적인 위반을 볼 수 있습니다. 이는 하나의 마이크로 프론트엔드가 이상적으로는 분리되어야 할 여러 책임이나 관심사를 맡을 때 발생합니다. 예를 들어, 결제 처리 마이크로 프론트엔드가 사용자 등록도 처리하는 경우입니다.

단일 책임 원칙(SRP)은 객체 지향 프로그래밍(OOP)을 위한 SOLID 원칙의 기본 원칙 중 하나입니다. 이는 복잡성을 줄이려고 시도하는데, 결과적으로 오류를 줄이고 부품을 더 쉽게 교체할 수 있게 만듭니다. 결과적으로 구현이 아마도 더 전용적이고 경량화될 것이며, 더 쉽게 테스트할 수 있을 것입니다.

"마이크로"라는 용어가 특정 코드 라인 제한 등을 의미하는 것이 아니라 애플리케이션의 단일 하위 도메인에 중점을 둔다는 것을 항상 기억하십시오.

이 안티패턴의 주요 특성은 다음과 같습니다:

불분명한 소유권: 특정 기능이나 마이크로 프론트엔드의 책임자가 누구인지 물었을 때 아무도 책임을 느끼지 않습니다.
재사용성 없음: "당신의 마이크로 프론트엔드에서 이 컴포넌트를 사용할 수 있습니다" 또는 "기술적인 이유로 당신의 마이크로 프론트엔드를 여기에 삽입할 수 있습니까?"와 같은 아이디어가 나올 때마다 대답은 아니오입니다.
도메인 중복: 단일 마이크로 프론트엔드 개발에 여러 PO 또는 도메인 전문가가 관여합니다.

물건을 원래 있어야 할 곳에 두십시오. 섞거나 짝짓지 마십시오.

## 스파게티 아키텍처

스파게티 아키텍처는 소프트웨어 아키텍처가 명확한 구조와 조직화가 부족하여 서로 얽혀있는 컴포넌트와 모듈들로 인해 엉망진창이 되는 것을 말한다. 이를 피하기 위한 좋은 모델은 모든 마이크로 프론트엔드를 중앙 위치, 즉 마이크로 프론트엔드 검색 서비스에서 제공하는 플랫 모델이다. 당연히 플랫한 상태를 유지하기 위해서는 어떤 마이크로 프론트엔드도 다른 마이크로 프론트엔드를 로드할 수 없다. 

그렇다면 한 마이크로 프론트엔드가 어떻게 다른 마이크로 프론트엔드의 컴포넌트(또는 다른 것)를 사용할 수 있을까? 간단히 말해서, 마이크로 프론트엔드는 느슨하게 결합되어야 한다(10번 참조). 따라서 건전한 아키텍처는 한 마이크로 프론트엔드가 다른 마이크로 프론트엔드를 알거나 로드할 필요가 없도록 조치를 취한다.

스파게티 아키텍처 안티패턴의 주요 특징은 다음과 같다:

- 복잡한 제어 흐름: 참조 지옥과 긴 꼬리에 이어 여기서도 같은 현상이 나타나는데, 잠재적으로 비동기 흐름이 모르는 사이에 기여하기도 한다. 
- 관심사 분리 부족: 경계가 제대로 정의되지 않고 모든 마이크로 프론트엔드가 기술적 수준에서 서로 다르게 보이고 느껴진다.
- 기술적 중복: 같은 문제를 서로 다른 방식으로 해결하는 것을 볼 수 있다. 예를 들어 여러 상태 컨테이너 라이브러리, 여러 프레임워크 또는 한 가지 일을 여러 가지 방법으로 해결하는 다른 것들이 있다.

기능을 제공하기 위해 호출의 그물에 의존하지 않고 느슨한 결합을 유지하자.

## 분산 데이터 불일치
분산 데이터 불일치는 마이크로 프론트엔드 간에 데이터를 공유할 때 발생하는 문제입니다. 도메인 관점에서 한 마이크로 프론트엔드에 속하는 데이터를 다른 마이크로 프론트엔드와 공유하게 되면 여러 가지 문제에 직면하게 됩니다.

데이터 일관성 문제가 그 중 하나입니다. 원본 데이터가 변경되면 변경 사항을 전파해야 하는데, 이것이 유일한 변경 가능성은 아닙니다. 데이터의 복제본을 받은 마이크로 프론트엔드에서 변경이 필요한 경우도 있습니다. 그런데 이것이 허용되는 것일까요? 원본과 복제본 간에 다시 차이가 발생하게 됩니다.

이상적으로는 데이터를 한 곳에서만 보관하고(단일 책임 원칙에 따라), 다른 마이크로 프론트엔드에서는 props나 관련 이벤트 발생 시 프래그먼트 형태로만 데이터에 접근해야 합니다.

이 안티 패턴의 주요 특징은 다음과 같습니다:

- 상충되는 작업: 두 개의 마이크로 프론트엔드가 동일한 데이터에 대해 작업하면 경쟁 상태나 알 수 없는 상태가 발생할 수 있습니다.
- 소유권 문제: 데이터의 소유자는 누구인가요? 상태 컨테이너에 출처가 불분명한 데이터가 있다면 소유권에 대한 의문이 있는 것입니다. 
- 비동기 업데이트: 아무 일도 일어나지 않는 동안 무언가 일어나고 있습니다. 아마도 보류 중인 작업, 지연된 요청 또는 예약된 작업 때문일 것입니다. 어떤 경우든 데이터는 명확한 소유권을 가지고 일관성을 유지해야 합니다.

데이터는 원래 속한 곳에 보관하고, 다른 마이크로 프론트엔드에서는 속성/props 등을 통해 간접적으로만 데이터에 접근하도록 해야 합니다.

## 인적 요소 무시

마이크로 프론트엔드를 도입할 때 간과하기 쉬운 것 중 하나가 바로 인적 요소입니다. 마이크로 프론트엔드는 기술적인 목표를 달성하기 위한 수단일 뿐만 아니라, 팀의 조직과 구조를 개선하기 위한 패턴이기도 합니다. 따라서 마이크로 프론트엔드 솔루션이 팀원들의 행복, 사기, 일과 삶의 균형에 부정적인 영향을 미친다면 무언가 잘못된 것입니다. 

이 안티 패턴의 주요 특징으로는 다음과 같은 것들이 있습니다:

- 과로: 장시간 근무, 주말 근무, 휴가 미사용 등은 모두 좋지 않은 신호입니다. 
- 마이크로 매니징: 팀에게 더 많은 권한을 부여하기보다는 상사들이 모든 행동을 통제하려 합니다. 팀의 권한이 줄어들고 있다면 변화가 필요한 때입니다.
- 비현실적인 기대: "그들이 정말 듣고 있는 걸까?" 또는 "누가 경영진에게 나쁜 소식을 전할까?"라는 생각이 든 적이 있나요? 현실을 직시하는 것이 두렵거나 현실이 기대에 부응하지 못한다면 실패는 불가피합니다. 

이를 극복하기 위해서는 중앙 집중식 관리를 최대한 피하고 팀을 강화하는 것이 중요합니다. 마이크로 프론트엔드 도입의 목적은 팀의 자율성과 책임감을 높이는 것이어야 합니다. 기술적인 이점도 중요하지만, 그보다 팀원들의 만족도와 동기부여가 우선시되어야 할 것입니다.

## 관측 가능성 회피

분산 시스템에서 디버깅은 항상 어려운 과제입니다. 하지만 어디에도 관측 가능성이 구현되어 있지 않다면, 예를 들어 어떤 마이크로 프론트엔드가 오류의 원인인지 모르거나 문제가 되는 부분을 로컬에서 디버깅할 수 없다면, 이 문제는 더욱 심각해집니다.

일반적으로 필요하거나 원하는 경우 하나 또는 여러 개의 마이크로 프론트엔드를 로컬 머신에서 실행할 수 있어야 합니다. 로컬 디버깅을 할 때는 전체 동작뿐만 아니라 상태, 성능 및 기타 메트릭도 테스트할 수 있어야 합니다.

이 안티 패턴의 주요 특징은 다음과 같습니다:

- 제한된 로깅: 문제가 발생했을 때, 적어도 어디서부터 살펴봐야 할지에 대한 단서를 제공하는 로그를 보고 싶을 것입니다. 하지만 로깅이 너무 적거나 전혀 없다면 이는 매우 어려울 것입니다.

- 부적절한 메트릭: 때로는 "성능 개선"과 같은 사용자 스토리가 등장합니다. 성능 저하가 있었다고 주장하는 스토리가 있을 때 상황은 더 나빠집니다. 올바른 메트릭을 사용하면 최소한 기준선을 설정하고 거기서부터 시작할 수 있습니다.

- 희박한 추적: 특히 분산 시스템에서는 장벽을 넘어 흔적을 따라갈 수 있어야 합니다. 추적이 희박하다면 근본 원인을 찾기가 매우 어려울 것입니다.

로깅, 추적 수집 등을 단순화하기 위한 중앙 집중식 솔루션을 도입하세요.

## 강한 결합

강한 결합은 엄밀히 말하면 안티 패턴이라고 할 수는 없습니다. 그러나 이 목록에 포함시켜야 할 여러 가지 이유가 있습니다. 특히, 강한 결합은 마이크로 프론트엔드를 확장할 때 발생하는 많은 문제의 근원이 되는 경우가 많습니다.

강한 결합은 모놀리식 아키텍처에는 실제로 원하는 많은 측면이 있다는 관찰에서 비롯됩니다. 우리는 무엇을 가져오고 사용하는지 알고 싶어 하며, 마치 우리가 통제하고 있는 것처럼 행동하고 싶어 합니다. 그러나 분산 시스템은 본질적으로 분산되어 있으므로 어떤 통제도 단순히 환상일 뿐입니다. 느슨한 결합으로 가는 것은 이 환상을 공식적으로 포기하는 방법일 뿐입니다.

왜 느슨한 결합을 선택해야 할까요? 처음에는 더 어려워 보일 수 있지만(예: 이벤트에 대해 생각할 때 - 어떤 마이크로 프론트엔드가 그것에 반응하고 어떻게 반응할지 정확히 알지 못한 채 추상적인 이벤트를 내보내는 것), 나중에는 더 자연스럽고 강력하게 느껴질 것입니다. 또한, 암묵적으로 강한 결합을 피하고, 따라서 숨겨진 모놀리스가 존재하는 이유의 상당 부분을 피할 수 있습니다.

이 안티 패턴의 주요 특징은 다음과 같습니다:

- 셧다운 불가능: 마이크로 프론트엔드의 락머스 테스트는 단일(어떤) 마이크로 프론트엔드를 셧다운하는 것입니다. 시스템이 계속 작동하면 모든 것이 괜찮습니다. 그렇지 않으면 존재해서는 안 되는 종속성이 있는 것입니다.
- 긴 온보딩 시간: 새로운 팀의 온보딩은 매우 빨라야 합니다. 표준 보일러플레이트에서 마이크로 프론트엔드를 생성하고, CI/CD 파이프라인을 설정하고, 코드를 푸시하세요. 더 많은 단계가 포함되어 있다면 전체 솔루션이 필요 이상으로 복잡할 수 있습니다. 항상 기억하세요: 마이크로 프론트엔드 솔루션은 일반적으로(전체적으로) 더 복잡하지만, 개별적으로 개발하기에는 더 간단해야 합니다.
- 정렬 노력 증가: 모든 것이 자율성에 관한 것입니다. 그래서 모놀리식 아키텍처에 비해 더 많은 정렬이 필요하다면 뭔가 잘못된 것입니다. 일반적으로 마이크로 프론트엔드는 팀이 필요한 결정을 내릴 수 있도록 해야 합니다. 정렬은 전체적인 사용자 경험을 만들기 위한 선택 사항일 뿐, 소프트웨어를 제공하기 위한 필수 사항이 아닙니다.

다른 마이크로 프론트엔드에 대한 기술적 지식(URL, 모듈 경로, 내부 이름 등)을 필요로 하는 직접 참조를 피하세요.

## 결론

이 글에서는 마이크로 프론트엔드를 도입할 때 자주 발생하는 10가지 안티 패턴에 대해 살펴보았습니다. 이러한 안티 패턴 중 일부는 여러분의 프로젝트에서 발견될 수 있겠지만, 상황에 따라 정당화될 수도 있습니다. 

따라서 이 목록을 절대적인 기준으로 받아들이기보다는, 해당 문제를 해결하는 동시에 팀과 같은 가용 자원에도 적합한 솔루션을 찾는 것이 중요합니다. 마이크로 프론트엔드 아키텍처를 성공적으로 구현하기 위해서는 도메인 분리, 느슨한 결합, 팀 자율성 등의 원칙을 염두에 두면서도 프로젝트의 특성과 상황에 맞게 유연하게 적용해야 할 것입니다.

