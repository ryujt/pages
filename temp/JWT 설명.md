# JWT 설명

[출처](https://dev.to/jaypmedia/jwt-explained-in-4-minutes-with-visuals-g3n)

## 소개

JSON Web Token(JWT)은 웹 애플리케이션의 사용자를 인증하는 두 가지 방법 중 하나로, 세션 인증과 함께 사용됩니다. 이 글에서는 JWT의 세부 사항, 구조 및 장단점에 대해 설명할 것입니다. JWT는 JSON Web Token의 약자로, 클라이언트와 서버 간에 JSON 형식으로 안전하게 정보를 전송하기 위해 사용되는 일반적인 무상태 사용자 인증 표준입니다. JWT는 기본적으로 인코딩되어 있으며 암호화되지 않습니다. 서버만 알고 있는 비밀 키를 사용하여 디지털 서명이 이루어집니다. 이 글에서는 암호화된 토큰이 아닌 서명된 비암호화 토큰에 초점을 맞출 것입니다.

JWT는 클라이언트와 서버 간의 안전한 정보 전달을 가능하게 하며, JSON 포맷 덕분에 경량이고 다양한 플랫폼에서 처리할 수 있는 이식성을 가집니다. 또한, 대부분의 프로그래밍 언어에서 JSON 파서를 쉽게 사용할 수 있어 개발자들에게 널리 사용됩니다. 하지만, JWT는 기본적으로 인코딩만 되어 있어 누구나 디코드하고 읽을 수 있으므로 민감한 정보를 저장해서는 안 됩니다. 또한, 서버 측에서는 로그아웃 시 JWT를 수동으로 무효화해야 하며, 토큰 블랙리스팅 같은 방법을 사용하여 인증에 재사용되지 않도록 해야 합니다.

이러한 JWT의 구조와 인증 흐름을 이해함으로써, 개발자는 보다 안전하고 효율적인 사용자 인증 시스템을 구축할 수 있게 됩니다.

### JWT와 세션 인증

웹 애플리케이션에서 사용자를 인증하는 데에는 주로 두 가지 방법이 사용됩니다: JWT(JSON Web Token) 인증과 세션 인증입니다. 이 두 방법은 각각 다른 방식으로 사용자의 신원을 확인하고 인증합니다.

#### 세션 인증
세션 인증 방식에서는 사용자가 로그인하면 서버가 사용자의 세션을 생성하고, 이 세션 정보를 서버에 저장합니다. 서버는 사용자에게 세션 ID를 발급하고, 사용자는 이 ID를 쿠키 형태로 저장하여 사용합니다. 사용자가 서버에 요청을 보낼 때마다 이 세션 ID가 함께 전송되며, 서버는 이 ID를 통해 사용자를 인식하고 인증합니다. 세션 인증의 경우, 서버는 사용자의 로그인 상태를 유지하기 위해 세션 정보를 메모리나 데이터베이스에 저장해야 합니다.

#### JWT 인증
반면, JWT 인증 방식에서는 사용자가 로그인하면 서버가 JSON 형식의 토큰을 생성하여 사용자에게 발급합니다. 이 토큰은 헤더(header), 페이로드(payload), 그리고 서명(signature)의 세 부분으로 구성됩니다. 헤더는 토큰의 유형(JWT)과 사용된 알고리즘을 명시합니다. 페이로드는 사용자에 대한 정보(클레임)와 토큰의 발행 및 만료 시간 등을 포함합니다. 서명은 헤더와 페이로드를 서버의 비밀 키로 암호화하여 생성됩니다. 사용자는 이 토큰을 클라이언트 측에 저장하고, 서버에 요청을 보낼 때마다 토큰을 함께 전송합니다. 서버는 토큰의 서명을 검증하여 사용자를 인증하며, 이 과정에서 서버는 사용자의 세션 정보를 저장할 필요가 없습니다. 이로 인해 JWT는 상태가 없는(stateless) 인증 방식으로 분류됩니다.

#### 비교
세션 인증과 JWT 인증 방식은 각각 장단점을 가집니다. 세션 인증은 서버가 사용자의 상태를 유지해야 하므로 서버의 리소스를 추가로 사용하게 되지만, 사용자의 인증 정보가 서버에만 저장되기 때문에 보안성이 높습니다. 반면, JWT 인증은 서버의 리소스를 절약할 수 있고 여러 플랫폼에서의 이용이 용이하지만, 토큰이 탈취되면 보안상 문제가 발생할 수 있습니다. 따라서, 어떤 인증 방식을 선택할지는 애플리케이션의 요구 사항과 보안, 성능 등을 고려하여 결정해야 합니다.

### JWT의 구조 및 장단점

#### 구조
JWT(JSON Web Token)는 세 부분으로 구성되어 있으며, 각 부분은 점(.)으로 구분됩니다. 이러한 부분들은 헤더(Header), 페이로드(Payload), 그리고 서명(Signature)입니다. 각 섹션은 Base64 인코딩 방식으로 인코딩됩니다.

1. **헤더(Header)**: 헤더는 주로 두 가지 정보를 담고 있습니다. 첫째, 토큰의 유형을 나타내는 `typ`이며, 이 경우에는 "JWT"입니다. 둘째, 사용된 서명 알고리즘을 나타내는 `alg`이며, 예를 들어 "HS256"이나 "RS256"과 같은 알고리즘이 사용됩니다.

   예시:
   ```json
   {
     "typ": "JWT",
     "alg": "HS256"
   }
   ```

2. **페이로드(Payload)**: 페이로드는 클레임(Claims)을 포함하고 있으며, 이는 사용자에 대한 정보나 추가 데이터 등을 의미합니다. 이는 토큰이 발급된 시간(`iat`), 만료 시간(`exp`), 주제(`sub`), 발급자(`iss`) 등의 정보를 포함할 수 있습니다.

   예시:
   ```json
   {
     "iss": "example_issuer",
     "sub": "user_id123",
     "exp": 1644768000,
     "iat": 1644744000
   }
   ```

3. **서명(Signature)**: 서명은 헤더와 페이로드, 그리고 서버만이 알고 있는 비밀 키를 사용하여 생성됩니다. 이 세 가지를 결합하고 주어진 알고리즘(HS256, RS256 등)에 따라 서명을 생성합니다. 이 서명을 통해 토큰의 무결성과 인증이 보장됩니다.

   생성 방법:
   ```
   HMAC-SHA256(base64urlEncode(header) + "." + base64urlEncode(payload), secret_salt)
   ```

#### 장점
- **경량성**: JWT는 JSON 포맷을 사용하기 때문에 통신에 있어서 경량입니다.
- **이식성**: 다양한 플랫폼 및 언어에서 쉽게 처리할 수 있어 이식성이 뛰어납니다.
- **JSON 파서의 보편성**: 대부분의 프로그래밍 언어에서 JSON 파싱이 가능하여 개발이 용이합니다.
- **변조 방지**: 서버 측에서만 알고 있는 비밀 키를 사용하여 서명되므로, 변조를 방지할 수 있습니다.
- **서버의 세션 정보 불필요**: JWT는 상태가 없는(stateless) 인증 방식이기 때문에, 서버 측에서 사용자의 세션 정보를 저장할 필요가 없습니다.

#### 단점
- **로그아웃 시 수동 처리 필요**: 사용자가 로그아웃하더라도 JWT는 유효기간이 만료될 때까지 유효하므로, 서버 측에서 JWT를 수동으로 무효화하는 처리가 필요합니다.
- **토큰 블랙리스팅**: JWT의 무효화를 위해 토큰 블랙리스팅 방법을 사용해야 하며, 이는 서버에 추가적인 부담을 줄 수 있습니다.
- **민감 정보 저장 불가**: JWT는 Base64 인코딩 방식으로 인코딩되기 때문에, 누구나 디코딩하여 내용을 볼 수 있습니다. 따라서, 민감한 정보를 페이로드에 저장해서는 안 됩니다.
- **보안 취약성**: JWT가 탈취될 경우, 토큰에 포함된 정보와 권한을 누구나 사용할 수 있게 됩니다. 이는 토큰 보관 방법에 대한 주의가 필요함을 의미합니다.

## JWT의 구조

JSON Web Token(JWT)은 웹 기반 인증 시스템에서 클라이언트와 서버 간에 안전하게 정보를 전송하기 위해 설계된 경량의 토큰입니다. JWT의 구조는 크게 세 부분으로 나뉩니다: 헤더(Header), 페이로드(Payload), 그리고 서명(Signature). 각 부분은 Base64 인코딩 방식으로 인코딩되어 점(.)으로 구분됩니다.

### 1. 헤더(Header)

헤더는 토큰의 유형과 사용된 서명 알고리즘에 대한 정보를 담고 있습니다. 일반적으로 두 가지 필드로 구성됩니다:

- `typ`: 토큰의 유형을 나타내며, JWT의 경우 "JWT"로 명시됩니다.
- `alg`: 사용된 서명 알고리즘을 나타내며, 예를 들어 HMAC SHA256이나 RSA와 같은 알고리즘이 사용됩니다.

헤더의 예시는 다음과 같습니다:

```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```

### 2. 페이로드(Payload)

페이로드는 토큰에 담길 실제 정보, 즉 클레임을 포함합니다. 클레임은 사용자에 대한 정보나 토큰에 대한 메타데이터 등을 의미하며, 여러 종류의 클레임이 있습니다:

- 등록된 클레임(Registered claims): 토큰의 발급자(`iss`), 주제(`sub`), 수신자(`aud`), 만료 시간(`exp`), 발급 시간(`iat`) 등과 같이 사전에 정의된 클레임으로, JWT의 처리를 위해 예약된 이름들입니다.
- 공개 클레임(Public claims): 충돌을 방지하기 위해 IANA JSON Web Token Registry에 등록되거나, URI 형식을 사용하여 정의할 수 있는 클레임입니다.
- 비공개 클레임(Private claims): 서버와 클라이언트 간의 합의 하에 사용되는 클레임으로, 사용자 정의 정보를 전송하기 위해 사용됩니다.

페이로드의 예시는 다음과 같습니다:

```json
{
  "iss": "example_issuer",
  "sub": "user_id123",
  "exp": 1644768000,
  "iat": 1644744000
}
```

### 3. 서명(Signature)

서명 부분은 헤더와 페이로드를 서버의 비밀 키와 함께 서명 알고리즘(헤더에서 지정된 `alg`)에 따라 암호화하여 생성됩니다. 이 과정은 토큰의 무결성을 보장하며, 서명을 통해 토큰이 변조되지 않았음을 검증할 수 있습니다.

서명은 다음 공식을 사용하여 생성됩니다:

```
HMAC-SHA256(base64urlEncode(header) + "." + base64urlEncode(payload), secret_salt)
```

이렇게 생성된 JWT는 세 부분을 점으로 연결하여 구성됩니다. 예를 들어:

```
base64urlEncode(header).base64urlEncode(payload).signature
```

JWT의 이러한 구조는 안전한 정보 전달, 인증 프로세스의 단순화 및 시스템 간의 느슨한 결합을 가능하게 하여, 웹 애플리케이션과 모바일 애플리케이션에서 널리 사용됩니다.

### JWT 인코딩 구조

JWT(JSON Web Token)의 인코딩 구조는 세 가지 주요 부분으로 구성됩니다: 헤더(Header), 페이로드(Payload), 그리고 서명(Signature). 이 세 부분은 각각 Base64 인코딩 방식으로 인코딩되며, 점(`.`)으로 구분되어 하나의 문자열로 결합됩니다. 이 구조는 JWT를 쉽게 전송하고 처리할 수 있게 해 주며, 웹이나 모바일 애플리케이션에서의 안전한 정보 교환을 가능하게 합니다.

#### 1. 헤더(Header)

헤더 부분은 두 가지 주요 정보를 담고 있습니다: 토큰의 유형(`typ`)과 사용된 서명 알고리즘(`alg`). 토큰의 유형은 일반적으로 "JWT"로 지정되며, 서명 알고리즘은 예를 들어 HMAC SHA256 또는 RSA와 같은 암호화 알고리즘을 의미합니다. 이 정보는 JWT가 어떻게 처리되어야 할지를 정의하는 데 도움을 줍니다.

헤더의 예시:
```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```

#### 2. 페이로드(Payload)

페이로드 부분은 클레임(Claims)을 포함하고 있으며, 이 클레임들은 사용자에 대한 정보나 추가 데이터를 담고 있습니다. 클레임에는 등록된 클레임(Registered claims)과 공개 클레임(Public claims), 비공개 클레임(Private claims) 등 여러 종류가 있습니다. 예를 들어, 토큰의 발급자(`iss`), 주제(`sub`), 만료 시간(`exp`), 발급 시간(`iat`) 등의 정보가 포함될 수 있습니다.

페이로드의 예시:
```json
{
  "iss": "example_issuer",
  "sub": "user_id123",
  "exp": 1644768000,
  "iat": 1644744000
}
```

#### 3. 서명(Signature)

서명 부분은 헤더와 페이로드, 그리고 서버만이 알고 있는 비밀 키를 사용하여 생성됩니다. 서명 알고리즘(헤더에서 지정된 `alg`)에 따라, 헤더와 페이로드를 결합한 후 이를 비밀 키와 함께 암호화하여 서명을 생성합니다. 이 서명을 통해 JWT의 무결성과 인증이 보장되며, 서버는 이 서명을 검증하여 토큰의 유효성을 확인할 수 있습니다.

서명 생성 방법:
```
HMAC-SHA256(base64urlEncode(header) + "." + base64urlEncode(payload), secret_salt)
```

이러한 세 부분을 결합하여 완성된 JWT는 다음과 같은 형식을 가집니다:
```
base64urlEncode(header).base64urlEncode(payload).signature
```

JWT의 이 인코딩 구조는 정보를 안전하게 전송하고, 인증 과정을 간소화하며, 다양한 시스템 간의 호환성을 제공하는 데 중요한 역할을 합니다.

### JWT 구조 디코드

JWT(JSON Web Token)는 웹 애플리케이션에서 클라이언트와 서버 간의 안전한 정보 전달을 위해 설계된 토큰 기반의 인증 시스템입니다. 각 JWT는 세 부분으로 구성되며, 이는 헤더(Header), 페이로드(Payload), 그리고 서명(Signature)입니다. 이 세 부분은 Base64 인코딩 방식으로 인코딩되어 점(`.`)으로 구분됩니다. 이러한 구조는 JWT의 정보를 안전하게 전송하고, 인증 과정을 간소화하며, 다양한 시스템 간의 호환성을 제공하는 데 중요한 역할을 합니다.

#### 1. 헤더(Header)

헤더 부분은 JWT의 유형과 사용된 서명 알고리즘에 대한 정보를 담고 있습니다. 일반적으로 두 가지 필드로 구성됩니다:

- `typ`: 토큰의 유형을 나타내며, JWT의 경우 "JWT"로 명시됩니다.
- `alg`: 사용된 서명 알고리즘을 나타내며, 예를 들어 HMAC SHA256 또는 RSA와 같은 암호화 알고리즘을 의미합니다.

헤더의 예시:
```json
{
  "typ": "JWT",
  "alg": "HS256"
}
```

이 정보는 JWT가 어떻게 처리되어야 할지를 정의하는 데 도움을 줍니다.

#### 2. 페이로드(Payload)

페이로드 부분은 클레임(Claims)을 포함하고 있으며, 이 클레임들은 사용자에 대한 정보나 추가 데이터를 담고 있습니다. 클레임에는 등록된 클레임(Registered claims)과 공개 클레임(Public claims), 비공개 클레임(Private claims) 등 여러 종류가 있습니다. 예를 들어, 토큰의 발급자(`iss`), 주제(`sub`), 만료 시간(`exp`), 발급 시간(`iat`) 등의 정보가 포함될 수 있습니다.

페이로드의 예시:
```json
{
  "iss": "example_issuer",
  "sub": "user_id123",
  "exp": 1644768000,
  "iat": 1644744000
}
```

#### 3. 서명(Signature)

서명 부분은 헤더와 페이로드, 그리고 서버만이 알고 있는 비밀 키를 사용하여 생성됩니다. 서명 알고리즘(헤더에서 지정된 `alg`)에 따라, 헤더와 페이로드를 결합한 후 이를 비밀 키와 함께 암호화하여 서명을 생성합니다. 이 서명을 통해 JWT의 무결성과 인증이 보장되며, 서버는 이 서명을 검증하여 토큰의 유효성을 확인할 수 있습니다.

서명 생성 방법:
```
HMAC-SHA256(base64urlEncode(header) + "." + base64urlEncode(payload), secret_salt)
```

이러한 세 부분을 결합하여 완성된 JWT는 다음과 같은 형식을 가집니다:
```
base64urlEncode(header).base64urlEncode(payload).signature
```

JWT를 디코드하는 과정은 이 세 부분을 분리하고, 각각을 Base64 디코딩하는 것을 포함합니다. 이를 통해 서버는 페이로드에서 사용자 정보와 토큰의 유효성을 검증할 수 있습니다. 하지만, 서명 부분은 비밀 키를 통해서만 검증할 수 있으므로, 이는 JWT가 서버에 의해 생성되었음을 보장합니다. 이러한 방식으로 JWT는 웹 애플리케이션에서 사용자 인증 및 정보 전달의 안전성을 제공합니다.

## JWT 인증 흐름

JWT 인증 흐름은 사용자가 웹 애플리케이션에 로그인하고 서버로부터 안전하게 인증 토큰을 받아, 이후의 요청에서 이 토큰을 사용하여 자신을 인증하는 과정을 포함합니다. 이 과정은 몇 가지 주요 단계로 나눌 수 있습니다.

### 인증 단계

사용자는 웹 애플리케이션에 로그인하기 위해 사용자 이름과 비밀번호, 혹은 구글이나 페이스북과 같은 제3자 인증 서비스를 사용합니다. 서버는 제공된 자격 증명을 검증합니다. 이 단계에서 사용자의 자격 증명이 유효하다면, 다음 단계로 진행됩니다.

### 토큰 생성 및 클라이언트로의 전송

서버는 사용자의 자격 증명이 유효함을 확인한 후, 사용자에 대한 정보를 포함하는 JWT를 생성합니다. 이 JWT는 헤더, 페이로드, 서명의 세 부분으로 구성됩니다. 서버는 이 토큰을 생성하고 클라이언트에게 전송합니다. 클라이언트는 이 토큰을 저장해 두었다가 나중에 서버로 요청을 보낼 때 사용합니다.

### 클라이언트에서 서버로의 토큰 전송

클라이언트가 보호된 리소스에 접근하고자 할 때, 저장해 둔 JWT를 HTTP 요청의 Authorization 헤더에 'Bearer' 토큰으로 포함하여 서버로 전송합니다. 예를 들어, `axios.get(URL, { headers: { 'Authorization': 'Bearer ' + token, }, })`와 같은 형태로 요청을 보낼 수 있습니다.

### 토큰 검증

서버는 요청을 받으면 헤더에서 JWT를 추출하고, 이 토큰의 서명을 검증합니다. 서명은 서버가 토큰을 발급할 때 사용한 비밀 키를 사용하여 검증됩니다. 이 과정을 통해 JWT의 무결성이 보장되며, 토큰이 변조되지 않았음을 확인할 수 있습니다.

### 요청 승인

서명이 유효하다면, 서버는 토큰의 페이로드에서 사용자 정보를 추출하여 요청이 유효한 사용자에 의해 이루어졌는지 확인합니다. 이 정보를 바탕으로 사용자가 요청한 리소스에 대한 접근 권한이 있는지 판단합니다. 사용자가 해당 리소스에 접근할 권한이 있다면, 서버는 요청된 데이터를 클라이언트에게 전송합니다. 만약 사용자가 권한이 없다면, 서버는 오류 메시지를 반환합니다.

이러한 JWT 인증 흐름은 상태를 유지하지 않는(stateless) 방식으로, 서버가 사용자의 세션을 관리할 필요가 없어 시스템의 확장성과 유지 보수성을 향상시킵니다. 또한, JWT는 JSON 포맷을 사용하기 때문에 웹뿐만 아니라 모바일 애플리케이션과 같은 다양한 플랫폼에서도 쉽게 사용될 수 있습니다.

### 인증 단계

인증 단계는 사용자가 웹 애플리케이션에 로그인하는 과정으로 시작됩니다. 사용자는 자신의 사용자 이름과 비밀번호를 입력하거나, 구글, 페이스북과 같은 제3자 인증 서비스를 통해 로그인할 수 있습니다. 이러한 자격 증명은 서버에 전송되어 검증됩니다. 서버는 이 자격 증명을 확인하고, 유효한 경우 사용자를 인증하며, 다음 단계로 진행합니다.

이 단계는 사용자가 누구인지를 확인하는 첫 번째 절차로, 보안의 첫 관문입니다. 사용자가 제공한 정보가 데이터베이스에 저장된 정보와 일치하는지 확인함으로써, 해당 사용자가 실제로 그 계정의 소유자임을 검증합니다. 이 과정에서, 비밀번호는 해시와 같은 방법으로 암호화되어 저장되며, 로그인 시 제출된 비밀번호도 같은 방식으로 암호화되어 저장된 해시와 비교됩니다.

제3자 인증 서비스를 사용하는 경우, 사용자는 해당 서비스를 통해 이미 인증을 받았기 때문에, 서비스는 사용자의 신원 정보와 함께 액세스 토큰을 서버에 전달합니다. 서버는 이 액세스 토큰을 사용하여 제3자 서비스로부터 사용자의 신원을 확인하고, 인증 과정을 완료합니다.

이 인증 단계는 사용자가 누구인지를 확인하는 중요한 절차이며, 이후의 토큰 생성 및 전송, 토큰을 이용한 인증 요청 등의 과정으로 이어집니다. 사용자의 자격 증명이 성공적으로 검증되면, 서버는 사용자에 대한 정보를 포함하는 JSON Web Token(JWT)을 생성하고, 이를 사용자에게 전송합니다. 사용자는 이 토큰을 저장해 두었다가, 서버에 요청을 보낼 때마다 이 토큰을 함께 전송하여 자신을 인증합니다. 이러한 과정을 통해, 사용자는 로그인 이후에도 서버와 안전하게 통신할 수 있게 됩니다.

### 토큰 생성 및 클라이언트로의 전송

서버는 사용자의 자격 증명이 유효함을 확인한 후, 사용자에 대한 정보를 포함하는 JWT를 생성합니다. 이 과정은 다음과 같습니다:

1. **헤더(Header) 생성**: JWT의 첫 번째 부분은 헤더입니다. 헤더는 토큰의 유형(`JWT`)과 서명 알고리즘(`HS256`, `RS256` 등)을 명시합니다. 예를 들어, 서명 알고리즘이 `HS256`인 경우, 헤더는 다음과 같이 구성됩니다:
   ```json
   {
     "typ": "JWT",
     "alg": "HS256"
   }
   ```
   이 헤더는 Base64 인코딩 방식으로 인코딩됩니다.

2. **페이로드(Payload) 생성**: 페이로드는 사용자에 대한 정보(클레임)를 포함합니다. 이에는 발급자(`iss`), 주제(`sub`), 만료 시간(`exp`), 발급 시간(`iat`) 등의 정보가 포함될 수 있습니다. 예를 들어:
   ```json
   {
     "iss": "example_issuer",
     "sub": "user_id123",
     "exp": 1644768000,
     "iat": 1644744000
   }
   ```
   페이로드 역시 Base64 인코딩 방식으로 인코딩됩니다.

3. **서명(Signature) 생성**: 서명은 헤더와 페이로드를 결합한 후, 서버의 비밀 키(`secret_salt`)를 사용하여 지정된 알고리즘(`HS256`, `RS256` 등)에 따라 생성됩니다. 예를 들어, `HS256` 알고리즘을 사용하는 경우, 서명은 다음과 같이 생성됩니다:
   ```
   HMAC-SHA256(base64urlEncode(header) + "." + base64urlEncode(payload), secret_salt)
   ```
   이 서명은 JWT의 무결성과 인증을 보장하는 데 중요한 역할을 합니다.

4. **JWT 완성**: 위의 세 부분(헤더, 페이로드, 서명)을 점(`.`)으로 연결하여 최종 JWT를 완성합니다. 예시는 다음과 같습니다:
   ```
   base64urlEncode(header).base64urlEncode(payload).signature
   ```

5. **클라이언트로의 전송**: 생성된 JWT는 클라이언트에게 전송됩니다. 클라이언트는 이 토큰을 저장해 두었다가, 서버에 요청을 보낼 때마다 이 토큰을 Authorization 헤더에 포함하여 전송합니다. 이를 통해 클라이언트는 자신의 인증 상태를 유지할 수 있으며, 서버는 토큰을 검증하여 사용자의 요청을 승인할 수 있습니다.

이 과정을 통해, 서버는 안전하게 사용자 정보를 포함한 JWT를 생성하고, 클라이언트에게 전송할 수 있습니다. 클라이언트는 이 토큰을 통해 서버와의 통신에서 자신을 인증할 수 있으며, 서버는 토큰의 서명을 검증하여 요청의 유효성을 확인할 수 있습니다. 이러한 방식으로 JWT는 웹 애플리케이션에서 사용자 인증을 위한 효율적이고 안전한 방법을 제공합니다.

### 클라이언트에서 서버로의 토큰 전송

클라이언트가 서버로부터 JWT를 받은 후, 이를 사용하여 보호된 리소스에 접근하고자 할 때, 클라이언트는 저장해 둔 JWT를 서버로 전송해야 합니다. 이 과정은 웹 애플리케이션에서 사용자 인증 및 권한 부여의 핵심 단계 중 하나입니다. 클라이언트에서 서버로의 JWT 전송 방법은 다음과 같습니다:

1. **HTTP 요청의 Authorization 헤더 사용**: 클라이언트는 HTTP 요청을 보낼 때, `Authorization` 헤더에 JWT를 포함시킵니다. 이때, JWT 앞에는 'Bearer'라는 접두사를 붙여서 전송합니다. 예를 들어, 헤더는 다음과 같이 구성될 수 있습니다:

```
Authorization: Bearer <your_token_here>
```

2. **토큰 전송 방법**: 클라이언트가 서버에 요청을 보낼 때, 예를 들어 REST API를 호출할 때, `Authorization` 헤더에 포함된 JWT와 함께 요청을 전송합니다. 예를 들어, JavaScript의 `fetch` 함수나 `axios`와 같은 HTTP 클라이언트 라이브러리를 사용하여 요청을 보낼 수 있습니다. 예시 코드는 다음과 같습니다:

```javascript
axios.get('https://example.com/api/protected', {
    headers: {
        'Authorization': `Bearer ${your_jwt_token}`
    }
})
```

3. **서버에서의 토큰 처리**: 서버는 클라이언트로부터 받은 요청의 `Authorization` 헤더를 확인하여 JWT를 추출합니다. 서버는 이 토큰의 유효성을 검증하고, 토큰에 포함된 사용자 정보와 권한을 확인하여 요청에 대한 처리를 결정합니다.

4. **보안 고려사항**: JWT는 탈취되거나 노출될 경우, 토큰에 포함된 권한을 가진 사용자로서 악의적인 행동을 할 수 있기 때문에, 통신 과정에서 HTTPS와 같은 안전한 프로토콜을 사용하여 데이터를 암호화하는 것이 중요합니다. 또한, 클라이언트 측에서는 JWT를 안전하게 저장하고 관리해야 합니다.

클라이언트에서 서버로의 JWT 전송 과정은 사용자 인증 및 권한 부여의 핵심적인 역할을 하며, 이를 통해 서버는 클라이언트의 요청을 안전하게 처리할 수 있습니다. 이 과정에서 JWT의 안전한 관리와 전송이 중요하며, 개발자는 보안을 위해 주의를 기울여야 합니다.

### 토큰 검증

토큰 검증 단계는 JWT 인증 흐름에서 중요한 역할을 합니다. 이 단계에서는 서버가 클라이언트로부터 받은 JWT의 유효성을 확인합니다. 서버는 JWT가 변조되지 않았으며, 발급자에 의해 실제로 발급된 것임을 검증해야 합니다. 이 과정은 다음과 같이 진행됩니다:

1. **토큰 추출**: 서버는 클라이언트로부터 HTTP 요청을 받을 때, 요청의 `Authorization` 헤더에서 JWT를 추출합니다. 클라이언트는 통상적으로 'Bearer' 접두사를 붙여 JWT를 전송합니다.

2. **헤더와 페이로드 디코딩**: 추출된 JWT는 Base64 인코딩되어 있으므로, 서버는 먼저 JWT의 헤더와 페이로드를 디코딩합니다. 이를 통해 JWT의 구조와 클레임 정보를 확인할 수 있습니다.

3. **서명 검증**: 가장 중요한 단계로, 서버는 JWT의 서명을 검증합니다. 서명은 JWT의 헤더와 페이로드, 그리고 서버만이 알고 있는 비밀 키(`secret_salt`)를 사용하여 생성된 것입니다. 서버는 동일한 알고리즘(`HS256`, `RS256` 등)을 사용하여 헤더와 페이로드를 결합한 후, 비밀 키로 서명을 다시 생성합니다. 이렇게 생성된 서명이 클라이언트로부터 받은 JWT의 서명과 일치하는지 비교합니다. 일치한다면, JWT가 변조되지 않았으며 유효함을 의미합니다.

4. **클레임 검증**: 서명이 유효하다면, 서버는 JWT의 페이로드에서 클레임을 추출하여 검증합니다. 이는 토큰의 발급자(`iss`), 주제(`sub`), 만료 시간(`exp`), 발급 시간(`iat`) 등의 정보를 확인하는 과정을 포함할 수 있습니다. 예를 들어, 서버는 토큰의 만료 시간이 현재 시간보다 이전인지 확인하여, 만료된 토큰을 거부할 수 있습니다.

5. **사용자 인증 및 권한 부여**: 모든 검증 단계가 성공적으로 완료되면, 서버는 JWT에 포함된 사용자의 신원과 권한 정보를 신뢰할 수 있습니다. 이를 바탕으로 서버는 사용자가 요청한 작업을 수행할 수 있는 권한이 있는지 결정하고, 해당 요청을 승인하거나 거부합니다.

토큰 검증 과정은 JWT의 안전성과 신뢰성을 보장하는 핵심 단계입니다. 이 과정을 통해, 서버는 변조되지 않은 유효한 토큰만을 수용하여, 보안을 유지하고 사용자의 요청에 대한 적절한 처리를 보장할 수 있습니다.

### 요청 승인

요청 승인 단계는 JWT 인증 흐름에서 매우 중요한 부분입니다. 이 단계에서 서버는 이전 단계에서 검증한 토큰을 바탕으로 사용자의 요청을 승인하거나 거부합니다. 사용자가 보호된 리소스에 접근하려 할 때, 서버는 다음과 같은 과정을 통해 요청을 처리합니다:

1. **토큰의 서명 검증**: 서버는 클라이언트로부터 받은 JWT의 서명을 검증합니다. 이는 서버가 토큰을 발급할 때 사용한 비밀 키를 사용하여 토큰의 무결성을 확인하는 과정입니다. 서명이 유효하면, 토큰이 변조되지 않았으며 서버에 의해 발급된 것임을 의미합니다.

2. **페이로드에서 사용자 정보 추출**: 서명 검증이 성공하면, 서버는 토큰의 페이로드에서 사용자 정보와 권한을 포함한 클레임을 추출합니다. 이 정보는 사용자가 요청한 작업을 수행할 수 있는 권한이 있는지를 판단하는 데 사용됩니다.

3. **사용자 권한 확인**: 서버는 페이로드에서 추출한 사용자 정보와 권한을 바탕으로, 사용자가 요청한 리소스에 접근할 수 있는 권한이 있는지 확인합니다. 예를 들어, 특정 API 엔드포인트에 대한 접근 권한이 있는지, 데이터를 수정할 수 있는 권한이 있는지 등을 판단합니다.

4. **요청 승인 또는 거부**: 사용자가 해당 리소스에 접근할 권한이 있다면, 서버는 요청을 승인하고 요청된 데이터를 클라이언트에게 전송합니다. 만약 사용자가 권한이 없거나 토큰이 유효하지 않은 경우, 서버는 오류 메시지와 함께 요청을 거부합니다. 이를 통해 무단 접근을 방지하고 시스템의 보안을 유지합니다.

이 과정을 통해, 서버는 JWT를 사용하여 사용자의 신원을 확인하고, 사용자가 요청한 작업을 수행할 수 있는 권한을 가지고 있는지를 판단합니다. JWT 인증 흐름은 상태가 없는(stateless) 방식으로 작동하므로, 서버는 세션 정보를 저장하거나 관리할 필요가 없어 시스템의 확장성과 성능이 개선됩니다. 또한, JWT는 다양한 플랫폼과 언어에서 쉽게 처리할 수 있어 웹 및 모바일 애플리케이션에서 널리 사용됩니다.

## JWT의 장점

JWT(JSON Web Token)는 웹 애플리케이션과 모바일 애플리케이션에서 사용자 인증을 관리하는 데 널리 사용되는 기술입니다. 이 기술은 여러 장점을 가지고 있어 개발자와 기업에게 매력적인 선택지가 됩니다. JWT의 주요 장점은 다음과 같습니다.

### 경량성

JWT는 JSON 포맷을 사용하여 정보를 구조화하기 때문에, 통신 과정에서 데이터의 부담을 최소화합니다. 이는 네트워크 대역폭을 절약하고, 특히 모바일 디바이스나 대역폭이 제한된 환경에서의 애플리케이션 성능을 향상시킵니다.

### 이식성

JWT는 JSON 포맷을 기반으로 하므로, 다양한 플랫폼 및 프로그래밍 언어에서 쉽게 처리할 수 있습니다. 이는 웹, 모바일, 서버리스 아키텍처 등 다양한 환경에서의 인증 관리를 용이하게 합니다.

### JSON 파서의 보편성

대부분의 프로그래밍 언어와 플랫폼은 JSON 파싱을 기본적으로 지원합니다. 이는 JWT를 쉽게 디코딩하고, 인증 정보를 추출하는 과정을 간소화합니다. 개발자는 별도의 파싱 라이브러리 없이도 JWT를 효율적으로 처리할 수 있습니다.

### 변조 방지

JWT는 디지털 서명을 통해 보호됩니다. 서버는 비밀 키를 사용하여 JWT를 서명하고, 이 서명을 통해 토큰의 무결성을 검증합니다. 이는 JWT가 중간에 변조되었는지 여부를 서버가 확인할 수 있게 하여, 보안성을 강화합니다.

### 서버의 세션 정보 불필요

JWT는 상태가 없는(stateless) 인증 메커니즘을 제공합니다. 이는 서버가 사용자의 세션 상태를 별도로 관리할 필요가 없음을 의미합니다. 서버는 각 요청마다 토큰만을 검증하여 사용자를 인증하므로, 서버의 리소스 사용을 최소화하고 확장성을 향상시킬 수 있습니다.

이러한 장점들은 JWT를 현대 웹 애플리케이션과 모바일 애플리케이션에서 사용자 인증을 관리하는 데 매우 유용하게 만듭니다. 특히, 분산 시스템과 마이크로서비스 아키텍처에서의 인증 관리에 있어서 JWT는 중요한 역할을 합니다.

### 경량성

JWT(JSON Web Token)의 경량성은 그 주요 장점 중 하나입니다. JWT는 JSON 포맷을 사용하여 데이터를 구조화하므로, 웹 또는 모바일 애플리케이션 간의 정보 교환 시 데이터 크기를 최소화할 수 있습니다. 이는 특히 대역폭이 제한된 환경이나 모바일 네트워크에서 애플리케이션의 성능을 향상시키는 데 유리합니다.

JWT는 헤더(Header), 페이로드(Payload), 서명(Signature)의 세 부분으로 구성되어 있으며, 각 부분은 Base64 인코딩 방식으로 인코딩되어 점(`.`)으로 구분됩니다. 이 구조는 정보를 효율적으로 압축하여 전송할 수 있게 하며, 통신 과정에서 발생할 수 있는 부하를 줄여줍니다.

또한, JWT는 클라이언트와 서버 간의 통신을 최적화하기 위해 설계되었습니다. 서버는 사용자의 인증 정보를 세션으로 관리할 필요가 없으므로, 서버의 리소스와 메모리 사용량을 줄일 수 있습니다. 클라이언트는 인증 후 받은 JWT를 로컬에 저장하고, 이후의 요청에서 이 토큰을 사용하여 서버에 자신을 인증합니다. 이 과정에서 JWT는 매 요청마다 서버로 전송되며, 서버는 토큰의 유효성만을 검증하면 되므로 처리 과정이 간소화됩니다.

이러한 특징들은 JWT를 특히 실시간 통신이 중요한 웹 애플리케이션, 모바일 애플리케이션, 싱글 페이지 애플리케이션(SPA), 마이크로서비스 아키텍처 등에서 인증 방식으로 채택하는 주된 이유입니다. 경량성은 네트워크 대역폭의 효율적 사용을 가능하게 하며, 애플리케이션의 반응 속도와 사용자 경험을 향상시키는 중요한 요소입니다.

### 이식성

JWT(JSON Web Token)의 이식성은 그것을 현대 웹 및 모바일 애플리케이션에서 인증 방식으로 선택하는 주요 이유 중 하나입니다. 이식성은 기본적으로 JWT가 다양한 플랫폼 및 프로그래밍 언어에서 쉽게 사용될 수 있음을 의미합니다. 이는 JWT가 JSON 포맷을 사용하여 데이터를 구조화하기 때문에 가능합니다. JSON은 대부분의 프로그래밍 언어에서 지원되며, 이로 인해 개발자는 특정 언어나 플랫폼에 구애받지 않고 JWT를 쉽게 생성, 전송, 디코딩할 수 있습니다.

웹 애플리케이션뿐만 아니라 모바일 애플리케이션, 심지어 서버리스 아키텍처와 같은 다양한 환경에서도 JWT를 효과적으로 사용할 수 있습니다. 예를 들어, 모바일 애플리케이션은 사용자 인증을 위해 서버로부터 JWT를 받아 로컬에 저장할 수 있으며, 이후의 API 요청에서 이 토큰을 사용하여 사용자를 인증할 수 있습니다.

또한, 마이크로서비스 아키텍처에서 서비스 간의 인증을 관리하는 데 JWT는 특히 유용합니다. 각 서비스는 독립적으로 인증을 처리할 수 있으며, JWT를 통해 서비스 간에 안전하게 사용자 정보를 교환할 수 있습니다. 이는 시스템의 복잡성을 줄이고, 개발 및 유지 보수를 용이하게 합니다.

이식성은 또한 클라우드 기반 인프라와의 호환성을 의미하기도 합니다. 클라우드 환경에서 애플리케이션을 배포하고 운영하는 경우, JWT는 클라우드 서비스 제공업체 간의 이동성을 제공합니다. 예를 들어, 애플리케이션이 한 클라우드 환경에서 다른 환경으로 이동해야 하는 경우, JWT 기반 인증 시스템은 변경 없이 그대로 사용될 수 있습니다.

결론적으로, JWT의 이식성은 다양한 환경과 플랫폼에서의 쉬운 통합과 사용을 가능하게 합니다. 이는 개발자가 보다 유연하게 애플리케이션을 설계하고, 다양한 환경에서의 호환성 문제를 최소화할 수 있게 해줍니다.

### JSON 파서의 보편성

JSON 파서의 보편성은 JWT(JSON Web Token)를 사용하는 주요 장점 중 하나입니다. 대부분의 프로그래밍 언어와 플랫폼은 JSON을 기본적으로 지원하며, 이는 JWT를 다룰 때 큰 이점을 제공합니다. JSON 포맷은 데이터를 쉽고 명확하게 표현할 수 있으며, 이로 인해 개발자들은 JWT를 생성, 전송, 디코딩하는 과정을 간단하게 처리할 수 있습니다.

#### 개발 편의성

JSON 파싱의 보편성은 다양한 환경에서 JWT를 쉽게 사용할 수 있게 해줍니다. 예를 들어, 웹 애플리케이션에서는 JavaScript를 사용하여 클라이언트 측에서 JWT를 쉽게 처리할 수 있습니다. 서버 측에서는 Node.js, Java, Python 등 다양한 서버 사이드 언어가 JSON 파싱을 내장하고 있거나, 간단한 라이브러리를 통해 지원합니다. 이는 개발자가 특정 언어나 플랫폼에 구애받지 않고, JWT를 통한 인증 시스템을 구축할 수 있게 해줍니다.

#### 데이터 교환의 용이성

JWT는 클라이언트와 서버 간의 안전한 데이터 교환을 위해 설계되었습니다. JSON 포맷 덕분에, 클라이언트는 서버로부터 받은 JWT를 쉽게 디코딩하고, 필요한 정보를 추출할 수 있습니다. 반대로, 서버도 클라이언트로부터 전송된 JWT를 빠르게 검증하고 처리할 수 있습니다. 이는 사용자 인증과 권한 부여 과정을 효율적으로 만들어, 애플리케이션의 성능을 향상시킵니다.

#### 보안성 강화

JWT는 서명을 통해 보안성을 강화합니다. 서버는 비밀 키를 사용하여 JWT에 서명하고, 이 서명을 통해 토큰의 무결성을 검증합니다. JSON 파싱의 보편성은 이 과정을 간소화합니다. 개발자는 표준 JSON 라이브러리를 사용하여 헤더와 페이로드를 쉽게 디코딩하고, 서명을 검증할 수 있습니다. 이는 JWT가 변조되지 않았으며, 신뢰할 수 있는 출처로부터 발급된 것임을 보장합니다.

#### 결론

JSON 파서의 보편성은 JWT를 현대 웹 애플리케이션과 모바일 애플리케이션에서 인증 방식으로 널리 사용되게 만드는 핵심 요소입니다. 이는 개발자에게 큰 유연성을 제공하며, 다양한 환경에서의 호환성 문제를 최소화합니다. 또한, JSON 포맷은 데이터 교환을 간소화하고, 애플리케이션의 보안성을 강화하는 데 기여합니다. 따라서, JWT는 안전하고 효율적인 사용자 인증 및 데이터 교환 방식으로서 그 가치가 높습니다.

### 변조 방지

JWT(JSON Web Token)의 변조 방지 기능은 그것을 안전한 사용자 인증 방식으로 만드는 핵심 요소 중 하나입니다. 변조 방지는 서버 측에서만 알고 있는 비밀 키(secret key)를 사용하여 디지털 서명을 생성함으로써 달성됩니다. 이 서명 과정은 JWT의 세 가지 주요 구성 요소인 헤더(Header), 페이로드(Payload), 그리고 서명(Signature)을 포함합니다.

#### 서명 생성 과정

1. **헤더와 페이로드 인코딩**: 헤더와 페이로드는 각각 Base64 인코딩 방식으로 인코딩됩니다. 이는 JWT의 구조를 생성하는 데 필수적인 단계입니다.

2. **서명**: 서명은 헤더와 페이로드를 결합한 문자열에 대해 서버의 비밀 키를 사용하여 지정된 알고리즘(HS256, RS256 등)에 따라 생성됩니다. 이 과정에서 생성된 디지털 서명은 JWT의 무결성과 인증을 보장합니다.

   ```
   signature = HMAC-SHA256(base64urlEncode(header) + "." + base64urlEncode(payload), secret_salt)
   ```

#### 변조 방지의 중요성

- **무결성 보장**: 서명을 통해 JWT가 전송 과정에서 변경되지 않았음을 확인할 수 있습니다. 서버는 받은 JWT의 서명을 검증하여, 이 서명이 서버에서 사용한 비밀 키와 일치하는지 확인합니다. 일치하지 않는 경우, JWT가 변조되었을 가능성이 있으므로 요청을 거부합니다.

- **보안성 강화**: 비밀 키는 서버에만 저장되며, 이 키는 서명 생성 및 검증 과정에서만 사용됩니다. 이러한 방식으로 JWT는 변조로부터 보호되며, 서버와 클라이언트 간의 안전한 정보 전달을 가능하게 합니다.

- **신뢰성 있는 인증**: 변조 방지 기능은 JWT를 사용한 인증 과정의 신뢰성을 높입니다. 서버는 서명이 유효한 JWT만을 수용하므로, 사용자는 자신의 인증 정보가 안전하게 처리됨을 확신할 수 있습니다.

#### 결론

JWT의 변조 방지 기능은 웹 애플리케이션과 모바일 애플리케이션에서 사용자 인증을 안전하게 관리하는 데 필수적입니다. 디지털 서명을 통해 JWT의 무결성을 보장함으로써, 개발자와 사용자 모두 데이터의 안전성과 인증 과정의 신뢰성을 확보할 수 있습니다. 이는 JWT를 현대적인 인증 시스템에서 널리 사용되는 이유 중 하나입니다.

### 서버의 세션 정보 불필요

JWT(JSON Web Token)의 가장 큰 장점 중 하나는 서버 측에서 사용자의 세션 정보를 저장할 필요가 없다는 것입니다. 이는 JWT가 상태가 없는(stateless) 인증 방식을 제공하기 때문입니다. 상태가 없는 인증 방식에서는 서버가 사용자의 로그인 상태나 세션 정보를 별도로 관리하지 않습니다. 대신, 사용자는 서버로부터 받은 JWT를 클라이언트 측에 저장하고, 서버에 요청을 보낼 때마다 이 토큰을 함께 전송합니다. 서버는 토큰 내의 정보를 바탕으로 사용자를 인증하고 요청을 처리합니다.

#### 세션 관리의 부담 감소

전통적인 세션 기반 인증 방식에서, 서버는 활성 사용자의 세션 정보를 메모리나 데이터베이스에 저장해야 합니다. 이는 서버의 리소스를 소모하며, 대규모 사용자가 동시에 접속하는 애플리케이션에서는 성능 저하의 원인이 될 수 있습니다. 반면, JWT를 사용할 경우, 서버는 사용자의 세션 상태를 저장하고 관리할 필요가 없어 서버의 부담이 크게 줄어듭니다. 이는 특히 분산 시스템이나 마이크로서비스 아키텍처에서의 확장성과 성능 향상에 기여합니다.

#### 확장성과 유연성의 향상

JWT의 상태가 없는 인증 방식은 서버의 확장성을 크게 향상시킵니다. 사용자의 인증 정보가 JWT 내에 포함되어 있기 때문에, 요청을 처리하는 서버가 바뀌더라도 추가적인 인증 과정 없이 요청을 처리할 수 있습니다. 이는 로드 밸런싱이나 서비스의 자동 확장과 같은 클라우드 환경의 특성과 잘 맞아 떨어집니다. 또한, 서버가 사용자의 세션 정보를 관리할 필요가 없으므로, 서버 간의 세션 동기화 문제를 해결할 필요가 없어 개발과 운영이 더욱 유연해집니다.

#### 보안성 강화

JWT는 서버 측에서만 알고 있는 비밀 키를 사용하여 디지털 서명되므로, 토큰의 무결성이 보장됩니다. 서버는 토큰을 받을 때마다 이 서명을 검증하여 토큰의 유효성을 확인합니다. 이 과정에서 서버는 사용자의 세션 정보를 저장하거나 확인할 필요가 없으며, 토큰이 변조되지 않았다면 유효한 요청으로 간주합니다. 이는 서버의 보안성을 강화하는 동시에, 세션 정보의 관리와 관련된 보안 취약점을 줄여줍니다.

#### 결론

JWT의 상태가 없는 인증 방식은 서버의 세션 관리 부담을 줄여주며, 시스템의 확장성과 유연성을 향상시킵니다. 또한, 디지털 서명을 통한 보안성 강화는 웹 애플리케이션과 모바일 애플리케이션의 안전한 사용자 인증을 가능하게 합니다. 이러한 장점으로 인해 JWT는 현대적인 인증 방식으로 널리 사용되고 있습니다.

## JWT의 단점

JWT(JSON Web Token)는 웹 애플리케이션과 모바일 애플리케이션에서 사용자 인증을 관리하는 데 많은 장점을 가지고 있지만, 몇 가지 단점도 존재합니다. 이러한 단점을 이해하는 것은 JWT를 사용할 때 발생할 수 있는 보안과 관리상의 이슈를 최소화하는 데 도움이 됩니다.

### 로그아웃 시 수동 처리 필요

JWT는 상태가 없는(stateless) 인증 방식이기 때문에, 서버는 사용자의 로그인 상태를 관리하지 않습니다. 이는 사용자가 로그아웃을 요청하더라도, 이미 발급된 JWT가 자동으로 무효화되지 않는다는 것을 의미합니다. 따라서, 서버 측에서는 로그아웃 요청을 받았을 때 해당 JWT를 수동으로 무효화하는 처리가 필요합니다. 이를 위해 일반적으로 사용되는 방법 중 하나는 토큰 블랙리스팅입니다.

### 토큰 블랙리스팅

토큰 블랙리스팅은 로그아웃한 사용자의 JWT를 더 이상 사용하지 못하게 하기 위해, 서버 측에서 무효 토큰 목록을 관리하는 방법입니다. 이 방법은 효과적이지만, 서버에 추가적인 부담을 줄 수 있으며, 대규모 시스템에서는 관리가 복잡해질 수 있습니다. 토큰 블랙리스팅을 위해서는 실시간으로 무효 토큰 목록을 업데이트하고, 모든 인증 요청에서 이 목록을 확인해야 합니다.

### 민감 정보 저장 불가

JWT는 Base64 인코딩 방식으로 인코딩되기 때문에, 누구나 쉽게 디코딩하여 내용을 볼 수 있습니다. 따라서, JWT 내에 민감한 정보(예: 비밀번호, 개인 식별 정보 등)를 저장해서는 안 됩니다. 이는 정보 유출의 위험을 증가시킬 수 있으며, JWT의 안전한 사용을 위해 반드시 고려해야 하는 사항입니다.

### 보안 취약성

JWT가 탈취되거나 노출될 경우, 토큰에 포함된 모든 권한을 악용할 수 있습니다. 이는 특히, 클라이언트 측에서 JWT를 안전하지 않은 방식으로 저장하거나 전송할 때 발생할 수 있습니다. 예를 들어, 로컬 스토리지에 JWT를 저장하는 경우, XSS(크로스 사이트 스크립팅) 공격을 통해 토큰이 유출될 수 있습니다. 따라서, JWT를 안전하게 저장하고 관리하는 것이 중요하며, 가능한 경우 HttpOnly 쿠키 등의 보다 안전한 저장 방법을 사용하는 것이 권장됩니다.

이러한 단점들에도 불구하고, JWT는 적절한 보안 조치와 함께 사용될 경우, 웹과 모바일 애플리케이션에서 효율적이고 안전한 사용자 인증 방식을 제공합니다. 하지만, JWT의 단점과 잠재적인 보안 위협을 이해하고, 이를 최소화하기 위한 방안을 마련하는 것이 중요합니다.

### 로그아웃 시 수동 처리 필요

JWT(JSON Web Token)의 상태가 없는(stateless) 특성으로 인해, 사용자가 로그아웃을 요청하더라도 이미 발급된 토큰은 자동으로 무효화되지 않습니다. 이는 사용자가 로그아웃을 해도, 토큰의 유효기간이 만료될 때까지 해당 토큰이 유효하게 남아있다는 것을 의미합니다. 따라서, 서버 측에서는 로그아웃 요청을 수동으로 처리해야 하는 부담이 있습니다.

#### 수동 처리의 필요성

서버는 사용자의 로그아웃 요청을 받았을 때, 해당 사용자의 JWT를 더 이상 유효하지 않게 처리해야 합니다. 이를 위해 일반적으로 사용되는 방법은 토큰 블랙리스팅입니다. 토큰 블랙리스팅은 로그아웃한 사용자의 토큰을 서버 측에서 관리하는 무효 토큰 목록에 추가하는 방법입니다. 이 목록에 추가된 토큰은 인증 요청 시 거부되어, 사용자가 로그아웃한 후에는 해당 토큰으로 보호된 리소스에 접근할 수 없게 됩니다.

#### 토큰 블랙리스팅의 구현

토큰 블랙리스팅을 구현하기 위해서는 서버가 모든 인증 요청을 받을 때마다 무효 토큰 목록을 확인해야 합니다. 이 과정에서 서버는 요청에 포함된 JWT가 블랙리스트에 있는지 검사하고, 포함되어 있다면 요청을 거부합니다. 이러한 처리는 추가적인 데이터베이스 조회나 캐시 접근을 필요로 할 수 있으며, 대규모 시스템에서는 이로 인한 성능 저하가 발생할 수 있습니다.

#### 로그아웃 처리의 과제

- **성능 저하**: 무효 토큰 목록을 관리하고, 모든 요청에 대해 이 목록을 조회하는 과정은 서버에 추가적인 부담을 줄 수 있습니다. 특히, 대규모 사용자를 대상으로 하는 서비스에서는 이로 인한 성능 저하가 문제가 될 수 있습니다.
- **관리의 복잡성**: 무효 토큰 목록의 관리는 시스템의 복잡성을 증가시킵니다. 목록을 어떻게 효율적으로 업데이트하고 관리할 것인지에 대한 고민이 필요하며, 이는 개발 및 운영의 부담을 증가시킵니다.

#### 결론

JWT의 상태가 없는 특성은 많은 장점을 제공하지만, 로그아웃 처리와 관련하여 몇 가지 과제를 안고 있습니다. 이러한 과제를 해결하기 위해서는 토큰 블랙리스팅과 같은 기술적인 해결책을 도입하고, 성능과 관리의 복잡성을 최소화하는 방안을 모색해야 합니다. 이는 JWT를 사용하는 시스템에서 안전하고 효율적인 사용자 인증 관리를 위해 반드시 고려해야 할 사항입니다.

### 토큰 블랙리스팅

토큰 블랙리스팅은 JWT(JSON Web Token)와 같은 상태가 없는(stateless) 인증 토큰의 단점 중 하나를 해결하기 위한 방법입니다. 사용자가 로그아웃을 하거나 토큰이 탈취되었을 때, 해당 토큰을 더 이상 사용할 수 없도록 만드는 과정입니다. 이는 서버 측에서 로그아웃 요청을 수동으로 처리해야 하는 부담을 가져오며, 대규모 시스템에서는 관리가 복잡해질 수 있습니다.

#### 토큰 블랙리스팅의 필요성

JWT는 그 자체로 상태 정보를 포함하고 있어 서버 측에서 별도로 사용자의 세션 상태를 유지할 필요가 없습니다. 하지만 이러한 상태가 없는 특성 때문에, 사용자가 로그아웃을 요청하더라도 이미 발급된 토큰은 유효기간이 만료될 때까지 계속 유효한 상태로 남아있습니다. 따라서, 사용자가 로그아웃을 요청하거나 보안상의 이유로 특정 토큰을 무효화해야 할 필요가 있을 때, 토큰 블랙리스팅이 필요하게 됩니다.

#### 토큰 블랙리스팅의 구현 방법

토큰 블랙리스팅을 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 무효 토큰의 목록을 데이터베이스나 메모리에 저장하는 것입니다. 서버는 인증 요청을 받을 때마다 이 목록을 확인하여 해당 토큰이 블랙리스트에 포함되어 있는지 검사합니다. 만약 토큰이 블랙리스트에 있다면, 요청은 거부되고 사용자는 인증되지 않은 것으로 간주됩니다.

#### 토큰 블랙리스팅의 단점

- **성능 저하**: 모든 인증 요청마다 블랙리스트를 확인해야 하므로, 요청 처리 시간이 늘어날 수 있습니다. 대규모 시스템에서는 이로 인한 성능 저하가 문제가 될 수 있습니다.
- **관리의 복잡성**: 무효 토큰 목록을 유지 관리하려면 추가적인 데이터베이스 작업이 필요하며, 시스템의 복잡성이 증가합니다. 또한, 무효 토큰 목록이 계속 커질 수 있으므로, 정기적인 정리가 필요할 수 있습니다.

#### 결론

토큰 블랙리스팅은 JWT의 상태가 없는 인증 방식에서 발생할 수 있는 보안 문제를 해결하는 데 유용한 방법입니다. 하지만, 이 방법을 사용할 때는 성능 저하와 관리의 복잡성과 같은 단점을 고려해야 합니다. 따라서, 토큰 블랙리스팅을 구현할 때는 이러한 단점을 최소화할 수 있는 방법을 찾고, 필요한 경우 다른 보안 조치와 함께 사용하는 것이 좋습니다.

### 민감 정보 저장 불가

JWT(JSON Web Token)는 사용자 인증 정보를 안전하게 전송하기 위해 설계된 표준이지만, 민감한 정보를 저장하는 용도로 사용되어서는 안 됩니다. JWT의 구조는 Base64 인코딩 방식으로 인코딩되어 있기 때문에, 누구나 쉽게 디코딩하여 내용을 볼 수 있습니다. 이러한 특성 때문에, JWT 내에 민감한 정보(예: 비밀번호, 개인 식별 정보 등)를 저장하는 것은 보안상 위험할 수 있습니다.

#### 민감 정보의 노출 위험

JWT가 디지털 서명을 통해 변조로부터 보호되더라도, 토큰 자체는 암호화되지 않은 상태로 전송되므로, 토큰을 가로채는 공격자는 토큰 내의 정보를 쉽게 읽을 수 있습니다. 따라서, JWT에 민감한 정보를 포함시키면, 이 정보가 노출될 위험이 있으며, 이는 사용자의 개인 정보 보호와 관련된 심각한 문제를 야기할 수 있습니다.

#### 안전한 정보 처리 방안

- **민감 정보 제외**: JWT는 사용자의 식별자나 권한 정보와 같이 필요한 최소한의 정보만을 포함해야 합니다. 민감한 정보는 서버 측에서 안전하게 관리하고, 필요할 때 안전한 방법으로 조회해야 합니다.
- **추가 보안 조치 고려**: 민감 정보를 전송해야 할 상황이라면, JWT 외에도 추가적인 보안 조치를 적용해야 합니다. 예를 들어, 전송 계층 보안(HTTPS)을 사용하여 데이터를 암호화하거나, 필요한 경우 JWT 자체를 암호화하는 방법을 고려할 수 있습니다.

#### 결론

JWT는 웹 애플리케이션과 모바일 애플리케이션에서 사용자 인증을 위한 효율적인 방법을 제공하지만, 민감 정보를 저장하는 용도로 사용되어서는 안 됩니다. JWT의 구조상 누구나 디코딩할 수 있기 때문에, 민감 정보의 노출 위험이 있습니다. 따라서, 보안을 유지하기 위해서는 JWT에는 최소한의 정보만 포함시키고, 민감 정보는 서버 측에서 안전하게 관리하는 것이 중요합니다.

### 보안 취약성

JWT(JSON Web Token)는 사용자 인증 정보를 안전하게 전송하기 위한 효율적인 방법을 제공하지만, 몇 가지 보안 취약성이 있습니다. 이러한 취약성을 이해하고 적절한 조치를 취하는 것은 애플리케이션의 보안을 강화하는 데 중요합니다.

#### 민감 정보 노출 위험

JWT는 Base64 인코딩 방식으로 인코딩되어 있어서 누구나 쉽게 디코딩하고 내용을 볼 수 있습니다. 따라서, JWT 내에 민감한 정보(예: 비밀번호, 개인 식별 정보 등)를 저장하는 것은 권장되지 않습니다. 이는 정보 유출의 위험을 증가시킬 수 있으며, JWT의 안전한 사용을 위해 반드시 고려해야 하는 사항입니다.

#### 토큰 탈취 및 재사용

JWT가 탈취되거나 노출될 경우, 토큰에 포함된 모든 권한을 악용할 수 있습니다. 이는 특히, 클라이언트 측에서 JWT를 안전하지 않은 방식으로 저장하거나 전송할 때 발생할 수 있습니다. 예를 들어, 로컬 스토리지에 JWT를 저장하는 경우, XSS(크로스 사이트 스크립팅) 공격을 통해 토큰이 유출될 수 있습니다. 따라서, JWT를 안전하게 저장하고 관리하는 것이 중요하며, 가능한 경우 HttpOnly 쿠키 등의 보다 안전한 저장 방법을 사용하는 것이 권장됩니다.

#### 로그아웃 및 세션 관리의 복잡성

JWT는 상태가 없는(stateless) 인증 방식이기 때문에, 서버는 사용자의 로그인 상태를 관리하지 않습니다. 이는 사용자가 로그아웃을 요청하더라도 이미 발급된 JWT가 자동으로 무효화되지 않는다는 것을 의미합니다. 따라서, 서버 측에서는 로그아웃 요청을 수동으로 처리해야 하며, 토큰 블랙리스팅과 같은 추가적인 조치가 필요할 수 있습니다. 이는 서버에 추가적인 부담을 주며, 대규모 시스템에서는 관리가 복잡해질 수 있습니다.

#### 보안 취약성에 대한 대응 방안

- **HTTPS 사용**: 데이터 전송 시 HTTPS를 사용하여 데이터를 암호화하고, 중간자 공격을 방지합니다.
- **토큰 만료 시간 단축**: 토큰의 만료 시간을 짧게 설정하여, 탈취된 토큰의 잠재적인 피해를 최소화합니다.
- **토큰 리프레시**: 장기간 사용되는 애플리케이션의 경우, 토큰 리프레시 메커니즘을 구현하여 정기적으로 토큰을 갱신합니다.
- **안전한 토큰 저장 방법 사용**: 클라이언트 측에서는 JWT를 HttpOnly 쿠키나 안전한 스토리지에 저장하여 XSS 공격으로부터 보호합니다.
- **토큰 블랙리스팅**: 로그아웃이나 토큰 무효화가 필요한 경우, 토큰 블랙리스팅을 통해 무효 토큰 목록을 관리합니다.

JWT의 보안 취약성에 대응하기 위해서는 이러한 조치들을 종합적으로 고려하여 시스템의 보안을 강화해야 합니다.